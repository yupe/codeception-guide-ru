# Продвинутое использование

В данном разделе мы рассмотрим некоторые техники и опции использование которых поможет вам улучшить ваши навыки в тестировании и сохранить качественную организацию вашего проекта.

## Интерактивная консоль

Интерактивная консоль добавлена для опробования команд Codeception перед тем, как они будут выполнены внутри тестов.
Данная возможность была анонсирована  начиная с версии 1.6.0.

![console](http://img267.imageshack.us/img267/204/003nk.png)

Вы можете запустить консоль с помощью команды

``` bash
php codecept.phar console suitename
```

Теперь вы можете выполнять любые команды соответствующего Guy класса и сразу же видеть результаты их выполнения. Это особенно полезно в случае, работы с модулями Selenium. Запуск Selenium и браузера для тестирования обычно занимает довольно продолжительное время. Однако при использовании коносли вы можете попробовать разнообразные селекторы и команды, после чего вы сможете быть уверенны в том, что написаный вами тест выполнится.

Полезный совет: покажите начальству, как резво вы манипулируете веб страницами с помощью консоли и Selenium. Так вы сможете убедить его в том, что довольно просто автоматизировать подобные вещи и начать использовать приемочное тестирование в проекте.

## Запуск из разных каталогов.

Если у вас есть несколько проектов содержащих Coeception тесты, вы можете использовать один `codecept.phar` файл для их запуска. Чтобы запустить Codeception из другой директории, вы можете добавить опцию `-c` к любой Codeception команде кроме `bootstrap`.

```

php codecept.phar run -c ~/projects/ecommerce/
php codecept.phar run -c ~/projects/drupal/
php codecept.phar generate:cept acceptance CreateArticle -c ~/projects/drupal/

```

Для создания проекта в директории отличной от той, где вы находитесь, просто добавьте ее путь как параметр.


```

php codecept.phar bootstrap ~/projects/drupal/


```

В сущности опция `-c` позволяет указать не только путь, но и файл конфигурации. Таким образом у вас может быть несколько различных файлов `codeception.yml` в одном тестовом наборе. Вы можете использовать их для указания разных переменных окружения и настроек. Просто передайте имя конфигурационного файла в параметре `-c` для того, чтобы выполнить тесты с настройками указанными в данном конфигурационном файле.

## Группы

Есть несколько путей позволяющих выполнить группу тестов. Вы можете выполнить тесты в определенной директории:

```

php codecept.phar run tests/acceptance/admin


```

Или выполнить одну (или несколько) групп тестов:

```

php codecept.phar run -g admin -g editor

```

В данном случае, будут выполнены все тесты принадлежащие группам admin или editor. Концепция групп взята из PHPUnit и его классических тестов которые ведут себя подобным образом. Чтобы добавить Cept тест к группе, используйте переменную `$scenario`:

``` php
<?php
$scenario->group('admin');
$scenario->group('editor');
// or
$scenario->group(array('admin', 'editor'))
// or
$scenario->groups(array('admin', 'editor'))

$I = new WebGuy($scenario);
$I->wantToTest('admin area');
?>
```
Для классических тестов и Cests тестов, чтобы добавить тест к группе можно использовать аннотацию `@group`.

``` php
<?php
/**
 * @group admin
 */
public function testAdminUser()
{
    $this->assertEquals('admin', User::find(1)->role);
}
?>
```
Та же аннотация может быть использована в Cest классах.

## Cest Классы

В случае, если вы хотите получить class-like структуру ваших Cept тестов, вместо использования простого PHP вы можете использовать Cest формат. Это очень просто и полностью совместимо с Cept сценариями. Если вы считаете, что ваши тесты стали достаточно длинными и вы хотите разбить их на части, вы можете поместить их внутрь класса.

Вы можете запустить Cest файл с помощью команды:

```
php codecept.phar generate:cest suitename CestName
```
Это сгенерирует файл похожий на этот:

``` php
<?php
class BasicCest
{

    public function _before()
    {
    }

    public function _after()
    {
    }

    // tests
    public function tryToTest(\WebGuy $I) {
    
    }
}
?>
```
**Каждый публичный метод Cest класса (кроме, начинающихся с `_`) будет выполнен как тест** куда первым параметром будет передан Guy класс и вторым параметром будет передана переменная `$scenario`. 

В методах `_before` и `_after`  можно указывать разнообразные настройки которые будут выполнятся до и после тестов данного класса. Это делает Cest тесты более гибкими, чем Cepts тесты которые основываются только на похожих методах в Helper классах.

Как вы могли видеть выше мы передаем класс Guy в метод `tryToTest`. Это позволяет писать сценарии тестирования точно так же, как мы делали это ранее.

``` php
<?php
class BasicCest
{
    // test
    public function checkLogin(\WebGuy $I) {
        $I->wantTo('log in to site');
        $I->amOnPage('/');
        $I->click('Login');
        $I->fillField('username', 'jon');
        $I->fillField('password','coltrane');
        $I->click('Enter');
        $I->see('Hello, Jon');
        $I->seeInCurrentUrl('/account');
    }
}
?>
```

Стоит отметить, что при использовании Cest файлов появляются некоторые ограничения. Вы не сможете работать с `_bootstrap.php` так как вы делали это в  Cept тестах. Иногда удобно хранить некоторые переменные, которые должны быть переданы тесту в bootstrap файлах. 
В файлах Cest вам придется включать все внешние переменные вручную с помощью глобальных или статических переменных.

В качестве обходного пути можно использовать классы фикстур [Fixtures](https://github.com/Codeception/Codeception/blob/master/src/Codeception/Util/Fixtures.php) которые являются по сути являются глобальным хранилищем переменных. Можно передать любые даныне из `_bootstrap.php` или ил любого другого места с помощью вызова `Fixtures::add()`. Вероятно так ж вы можете использовать в классах Cest методы `_before` и `_after` для загрузки фикстур в начале теста, и их удаления, после его выполнения, что так же довольно удобно.

Как вы могли видеть, классы Cest не имеют родителя на подобие `\Codeception\TestCase\Test` или `PHPUnit_Framework_TestCase`. Это сделано нарочно. Это позволяет вам расширять данные классы путем создания общего класса родителя.В данном классе вы можете описать общие поведения и методы, которые в дальнецшем могут быть использованы в унаследованных классах. При этом не забудьте установить для таких методов модификатор `protected` иначе они будут выполнены как тесты.

В дополнение, вы можете определить метод `_failed` в классах Cest который будет вызван в случае если в тесте произошла ошибка `error` или он 'провалился'.

## Рефакторинг

Во время роста базы тестов может потребоваться их рефакторинг, возможно понадобится выделить некоторые общие поведения и методы. Классический пример - действие `login` которое возможно будет вызываться практически в каждом тесте из тестового набора. Мудрое решение - написать данное действие однажды и использовать его во всех тестах, где это необходимо.

Вполне очевидно, что вы можете использовать собственные классы для определения похожих методов. 

``` php
<?php class TestCommons 
{
    public static $username = 'jon';
    public static $password = 'coltrane';

    public static logMeIn($I)
    {
        $I->amOnPage('/login');
        $I->fillField('username', 'jon');
        $I->fillField('password','coltrane');
        $I->click('Enter');
    }
}
?>
```

Этот файл затем может быть включен в файл `_bootstrap.php`

``` php
<?php
// bootstrap
require_once '/path/to/test/commons/TestCommons.php';
?>
```

и затем может быть использован в ваших сценариях:

``` php
<?php
$I = new WebGuy($scenario);
TestCommons::logMeIn($I);
?>
``` 

Теперь идея должна быть вам понятна. Codeception не обеспечивает единой стратегии при управлении тестами. Однако он достаточно гибок и позволяет создавать любые необходимые классы которые могут понадобиться вам во время тестирования. Используя похожий подход вы можете реализовать паттерны `PageObject` и `StepObject`.

## PageObject и StepObjects

В следующих версиях Codeception будет использовать PageObjects и StepObjects из коробки.
Однако сейчас вы можете попробовать реализовать ваши собственные версии данных объектов. У нас есть пара отличных сатей на данную тему, обратившись к которым вы сможете разобраться в том что же такое PageObjects, почему вы захотите их использовать и как они могут быть реализованы.

* [Управления стаями (тестов)](http://phpmaster.com/ruling-the-swarm-of-tests-with-codeception/) by Michael Bodnarchuk.
* [Реализация Page Objects в Codeception](http://jonstuff.blogspot.ca/2013/05/implementing-page-objects-in.html) by Jon Phipps.

## Заключение

Codeception - фреймворк, который на первый взгляд выглядит довольно просто. Однако он позволяет создавать достаточно мощные тесты имеющие единый API, рефакторить их и писать тесты быстрее используя интерактивную консоль. Тесты Codeception легко могут быть организованны в группы или в классы `Cest`. Вероятно это достаточно большой функционал для одного фреймворка. Не смотря на это Codeception следует принипу KISS: его просто изучить, просто использовать, просто расширять. 